# Basic Framework

## 算法解题思路

1. **循环**拆成相同的子问题 loop

2. **分类讨论**拆分多种情况 if-else

3. **分治法 divide and conquer**拆成**可继续拆分的子问题**直到**最小情况 base case**

### Idea & Typical Problems

**Idea**

把一个复杂的问题分为几个相同或者相似的子问题。再不断地把子问题分解为更小的子问题。直到子问题可以被直接求解。原问题的解即子问题的解得合并。是很多算法的基础（快速排序、归并排序）。

Treat the binary tree as a binary tree of problems that are generated by the original problem, then treverse the problems' binary tree.

**问题常见类型**

适合哪种问题，首先需要问题可以被分解，分解的问题答案可以被合并。问题缩小到一定规模可以很容易的被解决，子问题相互独立。

二叉树相关问题 - 使用二叉树的数据结构目的是，在解决问题时可以用分治法提高速度。

### Steps

**拆分问题顺序**

Step 1 - 画出问题拆分的树状图
Step 2 - 遍历问题树的所有节点

**遍历问题树实现的不同思路**

- recursion / iteration
- 纵向DFS / 横向BFS

### Recursive vs. Iterative

Note: The size of call-function is 8M.
Note: All recursive algorithms can be written as a _iterative_ version. Recursive version is a version using the system's call-function stack.
Example: 
[Subsets Problem](http://www.lintcode.com/zh-cn/problem/subsets-ii/#)
[Subsets Solution](http://www.jiuzhang.com/solutions/subsets/)

```python
# 1. recursive helper parameter and return type
# for return type, if we needs to record a max or min,
# we can use a global varible or put it both in the parameters and return type.
# Eg. subsets problem
# thisnode = (subsetStart, startIndex)
# background = nums
def recurhelper(background, thisnode, results):
    # 2. recursive helper exit
    if GOAL_TEST(thisnode):
        results.add(thisnode)
    
    # 3. expand this node and call recurhelper recursively.
    # EXPAND function returns hard copy of nodes
    for node in EXPAND(thisnode):
        recurhelper(background, node, results)
    
    return results
```

### Generic Tree Search Algorithm (BFS and DFS)

Reference - [USC-CSCI561-Lecture-Week2]

```c
function TREE_SEARCH(problem) return a solution or failure

frontier <- MAKE_QUEUE(MAKE_NODE(problem.INITIAL_STATE))
loop do
    if ISEMPTY(frontiers) then return failure
    node <- REMOVE_FIRST(frontiers)
    if problem.GOAL_TEST() applied to node.STATE succeeds
        then return SOLUTION(node)
    frontiers <- INSERT_ALL(EXPAND(node, problem), frontiers)
```

Note:
1. Always remove elements from the front
2. BFS places new elements at the end of the queue. FIFO.
3. DFS places new elements at the front of the queue(stack). LILO.