算法解题思路

1. 复合型问题分析，拆分成多个独立的部分
2. 分治法缩小问题，得到子问题，直到base case
3. 典型问题固定解法


## Divide & Conquer
**Treat the binary tree as a binary tree of problems that are generated by the original problem, then treverse the problems' binary tree.**
###Analyze the complexity###
TODO

# Binary Search
**Binary Search Template**
Source: [jiuzhang](http://www.jiuzhang.com/solutions/binary-search/)

```
class Solution {
    /**
     * @param nums: The integer array.
     * @param target: Target to find.
     * @return: The first position of target. Position starts from 0.
     */
    public int binarySearch(int[] nums, int target) {
        # First consider the case that the input is null or empty array.
        if (nums == null || nums.length == 0) {
            return -1;
        }
        
        # initial condition. The end is included in the range of the num, 
        # because the end is initialized to the length of nums minus one
        int start = 0, end = nums.length - 1;
        # Here, the condition should be start+1<end.
        # because when start=0 and end=1, then mid=0
        # and the start may not be updated.
        while (start + 1 < end) { # Note: use start+1<end as the condition to continue
            int mid = start + (end - start) / 2;
            if (nums[mid] == target) {
                end = mid;
            } else if (nums[mid] < target) {
                start = mid;
                // or start = mid + 1
            } else {
                end = mid;
                // or end = mid - 1
            }
        }
        
        # When the loop is end, decide where the first postion of target is.
        if (nums[start] == target) {
            return start;
        }
        if (nums[end] == target) {
            return end;
        }
        return -1;
    }
}
```
Note:
1. The loop control condition should be 

# Recursive, DFS and BFS

**Generic Tree Search Algorithm (BFS and DFS)**
Source: [USC-CSCI561-Lecture-Week2]

```
function TREE-SEARCH(problem) return a solution or failure

frontier <- MAKE-QUEUE(MAKE-NODE(problem.INITIAL-STATE))
loop do
    if EMPTY?(frontier) then return failure
    node <- REMOVE-FIRST(frontier)
    if problem.GOAL-TEST applied to node.STATE succeeds
        then return SOLUTION(node)
    frontier <- INSERT-ALL(EXPAND(node, problem), frontier)
```
Note:
1. Always remove elements from the front
2. BFS places new elements at the end of the queue. FIFO.
3. DFS places new elements at the front of the queue(stack). LILO.

**Recursive vs. Iterative**
Note: The size of call-function is 8M.
Note: All recursive algorithms can be written as a _iterative_ version. Recursive version is a version using the system's call-function stack.
Example: 
[Subsets Problem](http://www.lintcode.com/zh-cn/problem/subsets-ii/#)
[Subsets Solution](http://www.jiuzhang.com/solutions/subsets/)

```
# 1. recursive helper parameter and return type
# for return type, if we needs to record a max or min,
# we can use a global varible or put it both in the parameters and return type.
# Eg. subsets problem
# thisnode = (subsetStart, startIndex)
# background = nums
def recurhelper(background, thisnode, results):
    # 2. recursive helper exit
    if GOAL_TEST(thisnode):
        results.add(thisnode)
    
    # 3. expand this node and call recurhelper recursively.
    # EXPAND function returns hard copy of nodes
    for node in EXPAND(thisnode):
        recurhelper(background, node, results)
    
    return results
```