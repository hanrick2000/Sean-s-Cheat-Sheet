# Basic Framework

## 算法解题思路

1. **循环**拆成相同的子问题 loop

2. **分类讨论**拆分多种情况 if-else

3. **分治法 divide and conquer**拆成**可继续拆分的子问题**直到**最小情况 base case**

## 分类讨论

### Binary Search

# Binary Search

__适用的问题__
1. 不能死循环，每次循环会减少解空间。
2. 不能在循环中，把正确答案排除掉。

__Coding Tips__
1. 循环进入条件

start + 1 < end
start < end
start <= end

2. 调试方法

使用base case, Eg. [0], [0, 1], [0, 1, 2]

# Binary Search
**Binary Search Template**
Reference: [jiuzhang](http://www.jiuzhang.com/solutions/binary-search/)

```java
class Solution {
/**
* @param nums: The integer array.
* @param target: Target to find.
* @return: The first position of target. Position starts from 0.
*/
public int binarySearch(int[] nums, int target) {
# First consider the case that the input is null or empty array.
if (nums == null || nums.length == 0) {
return -1;
}
# initial condition. The end is included in the range of the num,
# because the end is initialized to the length of nums minus one
int start = 0, end = nums.length - 1;
# Here, the condition should be start+1<end.
# because when start=0 and end=1, then mid=0
# and the start may not be updated.
while (start + 1 < end) { # Note: use start+1<end as the condition to continue
int mid = start + (end - start) / 2;
if (nums[mid] == target) {
end = mid;
} else if (nums[mid] < target) {
start = mid;
// or start = mid + 1
} else {
end = mid;
// or end = mid - 1
}
}
# When the loop is end, decide where the first postion of target is.
if (nums[start] == target) {
return start;
}
if (nums[end] == target) {
return end;
}
return -1;
}
}
```

Note:
1. The loop control condition should be

## Divide and Conquer

### Idea & Typical Problems

**Idea**

把一个复杂的问题分为几个相同或者相似的子问题。再不断地把子问题分解为更小的子问题。直到子问题可以被直接求解。原问题的解即子问题的解得合并。是很多算法的基础（快速排序、归并排序）。

Treat the binary tree as a binary tree of problems that are generated by the original problem, then treverse the problems' binary tree.

**问题常见类型**

适合哪种问题，首先需要问题可以被分解，分解的问题答案可以被合并。问题缩小到一定规模可以很容易的被解决，子问题相互独立。

二叉树相关问题 - 使用二叉树的数据结构目的是，在解决问题时可以用分治法提高速度。

### Steps

**拆分问题顺序**

Step 1 - 画出问题拆分的树状图
Step 2 - 遍历问题树的所有节点

**遍历问题树实现的不同思路**

- recursion / iteration
- 纵向DFS / 横向BFS

### Recursive vs. Iterative

Note: The size of call-function is 8M.
Note: All recursive algorithms can be written as a _iterative_ version. Recursive version is a version using the system's call-function stack.
Example: 
[Subsets Problem](http://www.lintcode.com/zh-cn/problem/subsets-ii/#)
[Subsets Solution](http://www.jiuzhang.com/solutions/subsets/)

```python
# 1. recursive helper parameter and return type
# for return type, if we needs to record a max or min,
# we can use a global varible or put it both in the parameters and return type.
# Eg. subsets problem
# thisnode = (subsetStart, startIndex)
# background = nums
def recurhelper(background, thisnode, results):
    # 2. recursive helper exit
    if GOAL_TEST(thisnode):
        results.add(thisnode)
    
    # 3. expand this node and call recurhelper recursively.
    # EXPAND function returns hard copy of nodes
    for node in EXPAND(thisnode):
        recurhelper(background, node, results)
    
    return results
```

### Generic Tree Search Algorithm (BFS and DFS)

Reference - [USC-CSCI561-Lecture-Week2]

```c
function TREE_SEARCH(problem) return a solution or failure

frontier <- MAKE_QUEUE(MAKE_NODE(problem.INITIAL_STATE))
loop do
    if ISEMPTY(frontiers) then return failure
    node <- REMOVE_FIRST(frontiers)
    if problem.GOAL_TEST() applied to node.STATE succeeds
        then return SOLUTION(node)
    frontiers <- INSERT_ALL(EXPAND(node, problem), frontiers)
```

Note:
1. Always remove elements from the front
2. BFS places new elements at the end of the queue. FIFO.
3. DFS places new elements at the front of the queue(stack). LILO.